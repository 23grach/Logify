<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Design System Tracker</title>
  <style>
    /**
     * Global CSS reset and box-sizing for consistent rendering
     * across all browsers and elements
     */
    * {
      box-sizing: border-box;
    }

    /**
     * Base body styling with system fonts and layout structure
     * Uses flexbox for full-height layout management
     */
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 0;
      color: #1a1a1a;
      background: #ffffff;
      font-size: 14px;
      line-height: 1.5;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /**
     * Main container for the entire application layout
     * Manages vertical spacing and full-height distribution
     */
    .container {
      display: flex;
      flex-direction: column;
      padding: 20px;
      gap: 20px;
      width: 100%;
      height: 100%;
      justify-content: space-between;
      max-width: 100%;
    }

    /**
     * Scrollable content area that contains the main UI elements
     * Handles overflow with custom scrollbar styling
     */
    .content-container {
      display: flex;
      flex-direction: column;
      gap: 16px;
      flex: 1;
      overflow-y: auto;
    }

    /**
     * Custom webkit scrollbar styling for modern, minimal appearance
     * Applies to the main content container
     */
    .content-container::-webkit-scrollbar {
      width: 4px;
    }

    .content-container::-webkit-scrollbar-track {
      background: transparent;
    }

    .content-container::-webkit-scrollbar-thumb {
      background: #d0d0d0;
      border-radius: 2px;
      transition: background 0.15s ease;
    }

    .content-container::-webkit-scrollbar-thumb:hover {
      background: #a0a0a0;
    }

    /**
     * Firefox scrollbar styling for cross-browser consistency
     */
    .content-container {
      scrollbar-width: thin;
      scrollbar-color: #d0d0d0 transparent;
    }

    /**
     * Primary heading style with optimized typography
     * Uses negative letter-spacing for better visual density
     */
    .title {
      font-size: 20px;
      font-weight: 600;
      margin: 0;
      color: #1a1a1a;
      letter-spacing: -0.02em;
    }

    /**
     * Secondary heading style for section titles
     */
    .subtitle {
      font-size: 16px;
      font-weight: 500;
      margin: 0;
      color: #1a1a1a;
    }

    /**
     * Generic section container with consistent spacing
     */
    .section {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /**
     * Section header styling with uppercase transformation
     * Used for category labels and section dividers
     */
    .section-header {
      font-size: 14px;
      font-weight: 600;
      margin: 0;
      color: #666666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-size: 11px;
    }

    /**
     * Container for item lists with subtle background and border radius
     * Creates visual grouping for related elements
     */
    .items-container {
      display: flex;
      flex-direction: column;
      width: 100%;
      gap: 1px;
      background: #f5f5f5;
      border-radius: 6px;
      overflow: hidden;
    }

    /**
     * Individual item styling within lists
     * Provides consistent spacing and typography for list elements
     */
    .item {
      display: flex;
      gap: 12px;
      align-items: center;
      font-size: 13px;
      line-height: 1.4;
      padding: 10px 12px;
      background: #ffffff;
      border-bottom: 1px solid #f0f0f0;
    }

    /**
     * Remove border from the last item in a list
     * for cleaner visual appearance
     */
    .item:last-child {
      border-bottom: none;
    }

    /**
     * Type indicator styling for items
     * Shows element type with consistent formatting
     */
    .item-type {
      font-weight: 500;
      color: #888888;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      min-width: 60px;
    }

    /**
     * Item name styling with flexible width
     * Allows names to expand and wrap as needed
     */
    .item-name {
      font-weight: 400;
      color: #1a1a1a;
      flex: 1;
    }

    /**
     * Action buttons container with consistent spacing
     * Fixed at bottom of interface with visual separation
     */
    .actions-container {
      display: flex;
      flex-direction: column;
      width: 100%;
      gap: 8px;
      border-top: 1px solid #f0f0f0;
      padding-top: 16px;
    }

    /**
     * Base button styling with hover states and transitions
     * Provides consistent interactive elements throughout the UI
     */
    .button {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 6px;
      padding: 10px 16px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      font-family: inherit;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
      background: #ffffff;
      color: #1a1a1a;
    }

    /**
     * Button hover state for improved user feedback
     */
    .button:hover {
      background: #f8f8f8;
      border-color: #d0d0d0;
    }

    /**
     * Primary button variant with brand color
     * Used for main actions and call-to-action elements
     */
    .button-primary {
      background: #007AFF;
      color: white;
      border-color: #007AFF;
    }

    /**
     * Primary button hover state with darker shade
     */
    .button-primary:hover {
      background: #0056CC;
      border-color: #0056CC;
    }

    /**
     * Disabled button state styling
     * Provides visual feedback for non-interactive buttons
     */
    .button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      background: #f5f5f5;
      color: #999999;
      border-color: #e0e0e0;
    }

    /**
     * Disabled button hover state override
     * Prevents hover effects on disabled buttons
     */
    .button:disabled:hover {
      background: #f5f5f5;
      border-color: #e0e0e0;
    }

    /**
     * Element count display styling
     * Shows metadata with subdued appearance
     */
    .element-count {
      font-size: 12px;
      color: #888888;
      margin: 0;
    }

    /**
     * Centered message container for loading and empty states
     * Provides consistent layout for informational content
     */
    .center-message {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      height: 100%;
      gap: 16px;
      padding: 32px 24px;
    }

    /**
     * Message text styling for informational content
     * Constrained width for better readability
     */
    .message-text {
      font-size: 14px;
      color: #666666;
      max-width: 280px;
      line-height: 1.4;
      margin: 0;
    }

    /**
     * Loading spinner animation element
     * CSS-only spinner with smooth rotation
     */
    .loading-spinner {
      width: 24px;
      height: 24px;
      border: 2px solid #f0f0f0;
      border-top: 2px solid #007AFF;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    /**
     * Keyframe animation for loading spinner rotation
     */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /**
     * Visual divider element for section separation
     * Provides subtle visual breaks between content sections
     */
    .divider {
      height: 1px;
      background-color: #f0f0f0;
      margin: 8px 0;
      width: 100%;
    }
    
    /**
     * No changes message styling
     * Used when no modifications are detected
     */
    .no-changes {
      font-size: 13px;
      color: #888888;
      font-style: italic;
      padding: 20px 0;
      text-align: center;
    }
    
    /**
     * Base badge styling for count indicators
     * Provides consistent visual treatment for numeric badges
     */
    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 20px;
      height: 20px;
      padding: 0 6px;
      border-radius: 10px;
      font-size: 11px;
      font-weight: 600;
      margin-left: 8px;
    }
    
    /**
     * Badge variant for added elements
     * Green color scheme for positive additions
     */
    .badge-added {
      background-color: #E8F5E8;
      color: #2E7B32;
    }
    
    /**
     * Badge variant for changed elements
     * Orange color scheme for modifications
     */
    .badge-changed {
      background-color: #FFF4E6;
      color: #F57C00;
    }
    
    /**
     * Badge variant for removed elements
     * Red color scheme for deletions
     */
    .badge-removed {
      background-color: #FFEBEE;
      color: #D32F2F;
    }

    /**
     * Progress indicator container
     * Houses progress bar and percentage display
     */
    .progress-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
      max-width: 160px;
      margin-top: 12px;
    }
    
    /**
     * Progress bar track styling
     * Background container for progress indicator
     */
    .progress-bar {
      width: 100%;
      height: 4px;
      background-color: #f0f0f0;
      border-radius: 2px;
      overflow: hidden;
    }
    
    /**
     * Progress bar fill element
     * Animated width changes to show progress
     */
    .progress-fill {
      height: 100%;
      background-color: #007AFF;
      transition: width 0.3s ease;
      border-radius: 2px;
    }
    
    /**
     * Progress percentage text styling
     */
    .progress-text {
      font-size: 11px;
      font-weight: 500;
      color: #888888;
      text-align: center;
    }

    /**
     * Empty state container for initial and no-content screens
     * Provides consistent layout for informational states
     */
    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 40px 20px;
      gap: 12px;
    }

    /**
     * Empty state icon styling
     * Circular background with emoji or icon content
     */
    .empty-state-icon {
      width: 48px;
      height: 48px;
      background: #f5f5f5;
      border-radius: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      color: #888888;
    }

    /**
     * Section header with count display
     * Flexbox layout for title and badge alignment
     */
    .section-with-count {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    /**
     * Section title styling for headers with counts
     */
    .section-title {
      font-size: 14px;
      font-weight: 600;
      color: #1a1a1a;
      margin: 0;
    }

    /**
     * Comment input container for layout management
     */
    .comment-container {
      display: flex;
      flex-direction: column;
    }
    
    /**
     * Comment textarea styling with focus states
     * Provides user input area for changelog comments
     */
    .comment-input {
      width: 100%;
      min-height: 60px;
      padding: 12px 16px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      font-family: inherit;
      font-size: 13px;
      line-height: 1.4;
      color: #1a1a1a;
      background: #ffffff;
      resize: vertical;
      transition: all 0.15s ease;
    }
    
    /**
     * Comment input hover state for better interactivity
     */
    .comment-input:hover {
      border-color: #d0d0d0;
    }
    
    /**
     * Comment input focus state with brand color accent
     */
    .comment-input:focus {
      outline: none;
      border-color: #007AFF;
      box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.1);
    }
    
    /**
     * Placeholder text styling for comment input
     */
    .comment-input::placeholder {
      color: #999999;
    }

    /**
     * Custom scrollbar for comment textarea
     * Thinner scrollbar for smaller input area
     */
    .comment-input::-webkit-scrollbar {
      width: 3px;
    }

    .comment-input::-webkit-scrollbar-track {
      background: transparent;
    }

    .comment-input::-webkit-scrollbar-thumb {
      background: #d0d0d0;
      border-radius: 1px;
      transition: background 0.15s ease;
    }

    .comment-input::-webkit-scrollbar-thumb:hover {
      background: #a0a0a0;
    }

    /**
     * Global scrollbar styling for all elements
     * Ensures consistent scrollbar appearance throughout the app
     */
    *::-webkit-scrollbar {
      width: 4px;
      height: 4px;
    }

    *::-webkit-scrollbar-track {
      background: transparent;
    }

    *::-webkit-scrollbar-thumb {
      background: #d0d0d0;
      border-radius: 2px;
      transition: background 0.15s ease;
    }

    *::-webkit-scrollbar-thumb:hover {
      background: #a0a0a0;
    }

    *::-webkit-scrollbar-corner {
      background: transparent;
    }
  </style>
</head>
<body>
  <!-- Main application container -->
  <div class="container" id="app">
    <!-- Initial loading state - replaced by JavaScript -->
    <div class="center-message">
      <div class="loading-spinner"></div>
      <div class="message-text">Loading...</div>
    </div>
  </div>

  <script>
    // ======================== UTILITY FUNCTIONS ========================

    /**
     * Formats a timestamp into a human-readable date string.
     * Uses locale-specific formatting for better user experience.
     * 
     * @param {number} timestamp - Unix timestamp in milliseconds
     * @returns {string} Formatted date string (e.g., "Jan 15, 2024, 2:30 PM")
     */
    function formatDate(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    /**
     * Converts internal element types to user-friendly display names.
     * Handles legacy type names and provides consistent capitalization.
     * 
     * @param {string} type - Internal element type identifier
     * @returns {string} Human-readable type name
     */
    function formatElementType(type) {
      switch (type) {
        case 'component':
          return 'Component';
        case 'componentSet':
          return 'Component Set';
        case 'textStyle':
          return 'Text Style';
        case 'colorStyle':
        case 'paintStyle': // Legacy support for old data
          return 'Color Style';
        case 'effectStyle':
          return 'Effect Style';
        case 'gridStyle':
          return 'Grid Style';
        case 'variableCollection':
          return 'Variable Collection';
        case 'variable':
          return 'Variable';
        default:
          return type.charAt(0).toUpperCase() + type.slice(1);
      }
    }

    /**
     * Formats component names with variant properties for better readability.
     * Combines parent component name with variant property values.
     * Filters out empty values and duplicate parent names.
     * 
     * @param {Object} item - Design system element object
     * @param {string} item.name - Element name
     * @param {string} item.type - Element type
     * @param {Object} [item.variantProperties] - Variant property key-value pairs
     * @param {string} [item.parentName] - Parent component set name
     * @returns {string} Formatted component name with variants
     */
    function formatComponentName(item) {
      if (item.type === 'component' && item.variantProperties && Object.keys(item.variantProperties).length > 0) {
        // If we have the parent component set name, use it instead of the component's name
        const baseName = item.parentName || item.name.split('/')[0];
        
        // Format variant properties as Prop1=Value1, Prop2=Value2
        const variantProps = item.variantProperties;
        const propKeys = Object.keys(variantProps);
        
        // Filter out any empty values or properties that might duplicate the parent name
        const filteredProps = propKeys.filter(prop => {
          const value = variantProps[prop];
          return value && value.trim() !== '' && value.toLowerCase() !== baseName.toLowerCase();
        });
        
        if (filteredProps.length > 0) {
          const variantPropsString = filteredProps
            .map(prop => `${prop}=${variantProps[prop]}`)
            .join(', ');
          
          return `${baseName} (${variantPropsString})`;
        }
      }
      
      return item.name;
    }
    
    // ======================== SCREEN RENDERING FUNCTIONS ========================
    
    /**
     * Renders the initial system setup screen.
     * Displayed when no tracking data exists and system needs initialization.
     * 
     * @returns {string} HTML string for initialization screen
     */
    function renderInitScreen() {
      return `
        <div class="content-container">
          <div class="empty-state">
            <div class="empty-state-icon">📋</div>
            <h1 class="title">Initialize System</h1>
            <p class="message-text">
              Track changes to design system elements like components, styles, and variables. 
              No tracking data exists yet.
            </p>
          </div>
        </div>
        <div class="actions-container">
          <button class="button button-primary" id="initialize-button">Initialize System</button>
        </div>
      `;
    }
    
    /**
     * Renders the initialization completion screen.
     * Shows success message and count of recorded elements.
     * 
     * @param {number} count - Number of elements successfully recorded
     * @returns {string} HTML string for initialization complete screen
     */
    function renderInitializedScreen(count) {
      return `
        <div class="content-container">
          <div class="empty-state">
            <div class="empty-state-icon">✅</div>
            <h1 class="title">Initialization Complete</h1>
            <p class="message-text">
              Successfully recorded ${count} design system elements. 
              Future changes will be tracked automatically.
            </p>
            <p class="element-count">Elements recorded: ${count}</p>
          </div>
        </div>
        <div class="actions-container">
          <button class="button button-primary" id="view-records-button">View Records</button>
          <button class="button" id="ok-button">OK</button>
        </div>
      `;
    }
    
    /**
     * Renders the records view screen showing all tracked elements.
     * Groups elements by type and displays them in organized sections.
     * 
     * @param {Array} elements - Array of tracked design system elements
     * @param {number} timestamp - Last update timestamp
     * @returns {string} HTML string for records view screen
     */
    function renderRecordsScreen(elements, timestamp) {
      const date = formatDate(timestamp);
      
      // Group elements by type for organized display
      const groupedElements = {};
      elements.forEach(element => {
        if (!groupedElements[element.type]) {
          groupedElements[element.type] = [];
        }
        groupedElements[element.type].push(element);
      });
      
      // Generate HTML for each element type group
      let elementsHtml = '';
      Object.keys(groupedElements).sort().forEach(type => {
        const items = groupedElements[type];
        if (items.length > 0) {
          elementsHtml += `
            <div class="section">
              <div class="section-with-count">
                <h2 class="section-title">${formatElementType(type)}s</h2>
                <span class="badge badge-added">${items.length}</span>
              </div>
              <div class="items-container">
                ${items.map(item => `
                  <div class="item">
                    <div class="item-type">${formatElementType(item.type)}</div>
                    <div class="item-name">${formatComponentName(item)}</div>
                  </div>
                `).join('')}
              </div>
            </div>
          `;
        }
      });
      
      return `
        <div class="content-container">
          <div class="section">
            <h1 class="title">Current Records</h1>
            <p class="element-count">Last updated: ${date}</p>
            <p class="element-count">Total elements: ${elements.length}</p>
          </div>
          <div class="divider"></div>
          ${elementsHtml}
        </div>
        <div class="actions-container">
          <button class="button" id="back-button">Back</button>
        </div>
      `;
    }
    
    /**
     * Renders the main application screen with change detection results.
     * Displays added, modified, and removed elements with appropriate styling.
     * Includes comment input and action buttons when changes are detected.
     * 
     * @param {Object} changes - Change detection results object
     * @param {Array} changes.added - Array of newly added elements
     * @param {Array} changes.modified - Array of modified elements
     * @param {Array} changes.removed - Array of removed elements
     * @param {number} timestamp - Last scan timestamp
     * @param {boolean} hasChanges - Whether any changes were detected
     * @returns {string} HTML string for main application screen
     */
    function renderMainScreen(changes, timestamp, hasChanges) {
      const date = formatDate(timestamp);
      
      // Log changes for debugging purposes
      console.log('Rendering main screen with changes:', {
        hasChanges,
        added: changes.added.length,
        modified: changes.modified.length,
        removed: changes.removed.length
      });
      
      return `
        <div class="content-container">
          <div class="section">
            <h1 class="title">Design System Tracker</h1>
            <p class="element-count">Last scanned: ${date}</p>
          </div>
          
          ${hasChanges ? `
            <div class="divider"></div>
            
            ${changes.added.length > 0 ? `
              <div class="section">
                <div class="section-with-count">
                  <h2 class="section-title">Added</h2>
                  <span class="badge badge-added">${changes.added.length}</span>
                </div>
                <div class="items-container">
                  ${changes.added.map(item => `
                    <div class="item">
                      <div class="item-type">${formatElementType(item.type)}</div>
                      <div class="item-name">${formatComponentName(item)}</div>
                    </div>
                  `).join('')}
                </div>
              </div>
            ` : ''}
            
            ${changes.modified.length > 0 ? `
              <div class="section">
                <div class="section-with-count">
                  <h2 class="section-title">Changed</h2>
                  <span class="badge badge-changed">${changes.modified.length}</span>
                </div>
                <div class="items-container">
                  ${changes.modified.map(item => `
                    <div class="item">
                      <div class="item-type">${formatElementType(item.type)}</div>
                      <div class="item-name">${formatComponentName(item)}</div>
                    </div>
                  `).join('')}
                </div>
              </div>
            ` : ''}
            
            ${changes.removed.length > 0 ? `
              <div class="section">
                <div class="section-with-count">
                  <h2 class="section-title">Removed</h2>
                  <span class="badge badge-removed">${changes.removed.length}</span>
                </div>
                <div class="items-container">
                  ${changes.removed.map(item => `
                    <div class="item">
                      <div class="item-type">${formatElementType(item.type)}</div>
                      <div class="item-name">${formatComponentName(item)}</div>
                    </div>
                  `).join('')}
                </div>
              </div>
            ` : ''}
          ` : `
            <div class="section">
              <div class="no-changes">No changes detected since last update</div>
            </div>
          `}
        </div>
        
        <div class="actions-container">
          ${hasChanges ? `
            <div class="comment-container">
              <textarea 
                class="comment-input" 
                id="comment-input" 
                placeholder="Describe the changes or provide context..."
                maxlength="500"
              ></textarea>
            </div>
          ` : ''}
          <button class="button button-primary" id="add-to-figma-button" ${!hasChanges ? 'disabled' : ''}>Add to Figma</button>
          <button class="button" id="skip-version-button" ${!hasChanges ? 'disabled' : ''}>Skip Version</button>
          <button class="button" id="refresh-button">Refresh</button>
          <button class="button" id="view-records-button">View Records</button>
        </div>
      `;
    }
    
    /**
     * Renders a loading screen with optional progress indicator.
     * Used during async operations to provide user feedback.
     * 
     * @param {string} [message='Processing...'] - Loading message to display
     * @param {number|null} [progress=null] - Progress percentage (0-100) or null for indeterminate
     * @returns {string} HTML string for loading screen
     */
    function renderLoadingScreen(message = 'Processing...', progress = null) {
      return `
        <div class="center-message">
          <div class="loading-spinner"></div>
          <div class="message-text">${message}</div>
          ${progress !== null ? `
            <div class="progress-container">
              <div class="progress-bar">
                <div class="progress-fill" style="width: ${progress}%"></div>
              </div>
              <div class="progress-text">${progress}%</div>
            </div>
          ` : ''}
        </div>
      `;
    }
    
    /**
     * Renders an error screen with retry functionality.
     * Displays error message and provides option to retry the failed operation.
     * 
     * @param {string} message - Error message to display to user
     * @returns {string} HTML string for error screen
     */
    function renderErrorScreen(message) {
      return `
        <div class="center-message">
          <div class="empty-state-icon">⚠️</div>
          <div class="message-text">Error: ${message}</div>
          <button class="button button-primary" id="refresh-button">Retry</button>
        </div>
      `;
    }
    
    // ======================== STATE MANAGEMENT ========================
    
    /**
     * Current changes data from the last scan
     * @type {Object|null}
     */
    let currentChanges = null;
    
    /**
     * Timeout handle for debounced refresh operations
     * @type {number|null}
     */
    let refreshTimeout = null;
    
    // ======================== EVENT HANDLING ========================
    
    /**
     * Debounced refresh function to prevent rapid successive calls.
     * Cancels previous timeout and schedules a new refresh operation.
     * Provides smooth user experience during multiple refresh requests.
     */
    function debouncedRefresh() {
      if (refreshTimeout) {
        clearTimeout(refreshTimeout);
      }
      
      refreshTimeout = setTimeout(() => {
        renderUI(renderLoadingScreen('Scanning for changes...'));
        parent.postMessage({ pluginMessage: { type: 'refresh' } }, '*');
      }, 300);
    }
    
    /**
     * Sets up event listeners for all interactive elements in the current UI.
     * Dynamically attaches listeners based on elements present in the DOM.
     * Called after each UI render to ensure proper event handling.
     */
    function setupEventListeners() {
      // Initialize System button - starts the tracking system
      const initializeButton = document.getElementById('initialize-button');
      if (initializeButton) {
        initializeButton.addEventListener('click', () => {
          renderUI(renderLoadingScreen('Initializing system...'));
          parent.postMessage({ pluginMessage: { type: 'initialize' } }, '*');
        });
      }
      
      // View Records button - shows all tracked elements
      const viewRecordsButton = document.getElementById('view-records-button');
      if (viewRecordsButton) {
        viewRecordsButton.addEventListener('click', () => {
          renderUI(renderLoadingScreen('Loading records...'));
          parent.postMessage({ pluginMessage: { type: 'viewRecords' } }, '*');
        });
      }
      
      // OK button - continues from initialization complete screen
      const okButton = document.getElementById('ok-button');
      if (okButton) {
        okButton.addEventListener('click', () => {
          renderUI(renderLoadingScreen('Scanning for changes...'));
          parent.postMessage({ pluginMessage: { type: 'refresh' } }, '*');
        });
      }
      
      // Back button - returns from records view to main screen
      const backButton = document.getElementById('back-button');
      if (backButton) {
        backButton.addEventListener('click', () => {
          renderUI(renderLoadingScreen('Scanning for changes...'));
          parent.postMessage({ pluginMessage: { type: 'refresh' } }, '*');
        });
      }
      
      // Refresh button - rescans for changes
      const refreshButton = document.getElementById('refresh-button');
      if (refreshButton) {
        refreshButton.addEventListener('click', () => {
          debouncedRefresh();
        });
      }
      
      // Add to Figma button - creates changelog entry
      const addToFigmaButton = document.getElementById('add-to-figma-button');
      if (addToFigmaButton) {
        addToFigmaButton.addEventListener('click', () => {
          if (currentChanges) {
            // Get comment from input field
            const commentInput = document.getElementById('comment-input');
            const comment = commentInput ? commentInput.value.trim() : '';
            
            renderUI(renderLoadingScreen('Adding to Figma...'));
            parent.postMessage({ 
              pluginMessage: { 
                type: 'addToFigma',
                changes: currentChanges,
                comment: comment
              } 
            }, '*');
          }
        });
      }
      
      // Skip Version button - updates tracking without creating changelog
      const skipVersionButton = document.getElementById('skip-version-button');
      if (skipVersionButton) {
        skipVersionButton.addEventListener('click', () => {
          if (currentChanges) {
            renderUI(renderLoadingScreen('Skipping version...'));
            parent.postMessage({ 
              pluginMessage: { 
                type: 'skipVersion'
              } 
            }, '*');
          }
        });
      }
    }
    
    /**
     * Helper function to render UI and set up event listeners.
     * Combines DOM manipulation with event binding for complete UI updates.
     * 
     * @param {string} html - HTML string to render in the app container
     */
    function renderUI(html) {
      const appElement = document.getElementById('app');
      appElement.innerHTML = html;
      setupEventListeners();
    }

    // ======================== MESSAGE HANDLING ========================

    /**
     * Main message handler for plugin communication.
     * Processes messages from the plugin's main thread and updates UI accordingly.
     * Handles all plugin states and user interactions.
     */
    window.onmessage = (event) => {
      const message = event.data.pluginMessage;
      
      if (!message) return;
      
      switch (message.type) {
        case 'init':
          // Show initialization screen when no tracking data exists
          renderUI(renderInitScreen());
          break;
          
        case 'initialized':
          // Show initialization complete screen with element count
          renderUI(renderInitializedScreen(message.count));
          break;
          
        case 'scanComplete':
          // Show main screen with no changes detected
          currentChanges = { added: [], modified: [], removed: [] };
          renderUI(renderMainScreen(currentChanges, Date.now(), false));
          break;
          
        case 'changes':
          // Show main screen with detected changes
          currentChanges = message.changes;
          renderUI(renderMainScreen(message.changes, message.timestamp, message.hasChanges));
          break;
          
        case 'records':
          // Show records screen with all tracked elements
          renderUI(renderRecordsScreen(message.elements, message.timestamp));
          break;
          
        case 'addedToFigma':
          // Reset after successful changelog creation
          currentChanges = { added: [], modified: [], removed: [] };
          renderUI(renderMainScreen(currentChanges, Date.now(), false));
          break;
          
        case 'versionSkipped':
          // Reset after skipping version update
          currentChanges = { added: [], modified: [], removed: [] };
          renderUI(renderMainScreen(currentChanges, Date.now(), false));
          break;
          
        case 'updated':
          // Refresh after tracking data update
          renderUI(renderLoadingScreen('Scanning for changes...'));
          parent.postMessage({ pluginMessage: { type: 'refresh' } }, '*');
          break;
          
        case 'error':
          // Show error screen with retry option
          renderUI(renderErrorScreen(message.message));
          break;
          
        case 'progress':
          // Update loading screen with progress information
          renderUI(renderLoadingScreen(message.message, message.progress));
          break;
          
        default:
          console.log('Unknown message type:', message.type);
      }
    };
  </script>
</body>
</html> 